<template>
    <div class="editor" ref="editor" @keydown.alt="enablePickerButtons" @keyup="disablePickerButtons">
        <transition name="picker">
            <v-picker-container v-show="showPicker" :position="uniformSelectedPosition" ref="pickerContainer" >
                <component :is="pickerTypeComponent" :editor="uniformSelectedEditor"></component>
            </v-picker-container>
        </transition>
    </div>
</template>

<script lang="ts">
import Vue from "vue"
import PickerContainer from "./PickerContainer.vue"
import PickerOthers from "./PickerOthers.vue"
import PickerFloat from "./PickerFloat.vue"
import CodeMirror from "./codemirror/lib/codemirror"
import "./codemirror/mode/glsl/glsl"
import "./codemirror/addon/selection/active-line"
import "./codemirror/addon/edit/matchbrackets"
import "./codemirror/addon/edit/closebrackets"
import "./codemirror/addon/scroll/scrollpastend"
import "./codemirror/addon/fold/foldgutter"
import "./codemirror/addon/fold/foldcode"
import "./codemirror/addon/fold/brace-fold"
import "./codemirror/addon/fold/comment-fold"
import "./codemirror/addon/hint/show-hint"
import "./codemirror/addon/hint/glsl-hint"

enum LogEntryType {
    Error = "error",
    Warning = "warning"
}

export interface LogEntry {
    type: "error" | "warning",
    line: number,
    description: string
}
export interface UniformEditor {
    target: string
    type: "int" | "float" | "mat4" | "vec3"
    locked: boolean
    // setValue: ( value: any ) => void
}
export interface Range {
    from: CodeMirror.Position
    to: CodeMirror.Position
}

export default Vue.extend( {
    name: "editor",
    components: {
        "v-picker-container": PickerContainer,
        "v-picker-float": PickerFloat,
        "v-picker-others": PickerOthers
    },
    props: {
        value: {
            type: String,
            default: ""
        },
        log: {
            type: Array as () => LogEntry[],
            default: () => []
        },
        uniformsEditors: {
            type: Array as () => UniformEditor[],
            default: () => []
        }
    },
    data: () => ( {
        editor: {} as CodeMirror.Editor,
        document: {} as CodeMirror.Doc,
        uniforms: new Map() as Map< Range, UniformEditor >,
        pickerButtons: [] as CodeMirror.TextMarker[],
        uniformSelectedPosition: { x: 0, y: 0 },
        uniformSelectedEditor: {} as UniformEditor,
        showPicker: false
    } ),
    computed: {
        pickerTypeComponent(): string {
            return ( this.uniformSelectedEditor && this.uniformSelectedEditor.type === "float" ) ? "v-picker-float" : "v-picker-others"
        }
    },
    model: {
        event: "change"
    },
    mounted() {
        this.editor = CodeMirror( this.$refs.editor as HTMLElement, {
            value: this.value,
            mode: "glsl",
            lineNumbers: true,
            indentUnit: 4,
            gutters: [ "CodeMirror-markers", "CodeMirror-linenumbers", "CodeMirror-foldgutter" ],  // define el orden de los items en el margen
            extraKeys: { "Ctrl-Q": "toggleFold", "Ctrl-Space": "autocomplete" },
            styleActiveLine: true,
            matchBrackets: true,
            autoCloseBrackets: { pairs: "()[]{}''\"\"", explode: "[]{}()" },
            scrollPastEnd: true,
            foldGutter: true,
            foldOptions: { widget: "•••", minFoldSize: 1 },
            hintOptions: { completeSingle: false, alignWithWord: true }
        } )

        this.document = this.editor.getDoc()

        this.editor.on( "change", this.updateValue )
        this.editor.on( "keydown", this.handleShowHints )
        this.editor.focus()

        this.editor.getScrollerElement().appendChild( ( this.$refs.pickerContainer as Vue ).$el )
    },
    methods: {
        updateValue() {
            const value = this.editor.getValue()
            if ( this.value !== value ) {
                this.$emit( "change", value )
            }
        },
        handleShowHints( editor: CodeMirror.Editor, event: Event ) {
            if ( ! editor.state.completionActive ) {    // evito reactivacion innecesaria de hints
                // @ts-ignore
                const cursor = editor.getCursor()
                const token  = editor.getTokenAt( cursor )

                const cursorAtMiddleOfToken = cursor.ch < token.end

                if ( ! cursorAtMiddleOfToken ) {    // evito que se active al tipear a la mitad de una palabra
                    const modifiersActive = ( event as KeyboardEvent ).ctrlKey || ( event as KeyboardEvent ).metaKey    // evito que Ctrl+C active el autocompletado

                    if ( ! modifiersActive ) {
                        const which = ( event as KeyboardEvent ).which  // codigo de tecla ( a: 65, z: 90, etc )
                        const key = ( event as KeyboardEvent ).key      // character ingresado ( "a", "A", "å", etc )

                        const isLetterKey = ( which >= 65 && which <= 90 )  // si primero no filtrara por teclas correspondientes a letras, la key = "Enter" caeria en el rango "A"..."Z" ( por usar la "E" para la comparacion )
                        const isValidIdentifierLetter = isLetterKey && ( ( key >= "a" && key <= "z" ) || ( key >= "A" && key <= "z" ) )

                        if ( isValidIdentifierLetter || ( key === "_" ) || ( key === "#" ) ) {
                            // @ts-ignore
                            this.editor.showHint( { trigger: key } )
                        }
                    }
                }
            }
        },
        showLog( entries: Map < number, string[] >, type: LogEntryType ) {
            entries.forEach( ( descriptions, line ) => {
                const marker = document.createElement( "div" )
                marker.className = "CodeMirror-marker-" + type

                const markerTooltip = document.createElement( "ul" )
                markerTooltip.className = "CodeMirror-marker-tooltip"
                marker.appendChild( markerTooltip )

                for ( let description of descriptions ) {
                    const descriptionListItem = document.createElement( "li" )
                    descriptionListItem.textContent = description
                    markerTooltip.appendChild( descriptionListItem )
                }

                marker.addEventListener( "mouseenter", () => {
                    markerTooltip.classList.add( "visible" )
                } )
                marker.addEventListener( "mouseout", () => {
                    markerTooltip.classList.remove( "visible" )
                } )

                const lineHandle = this.editor.setGutterMarker( line, "CodeMirror-markers", marker )

                this.editor.addLineClass( line, "wrap", "CodeMirror-markedline-" + type )
                this.editor.addLineClass( line, "gutter", "CodeMirror-markedline-gutter-" + type )

                // @ts-ignore
                lineHandle.on( "change", ( lineHandle: CodeMirror.LineHandle, change: CodeMirror.EditorChange ) => {
                    // obtengo el numero de linea actualizado (puede haber cambiado por ediciones)
                    const currentLine = this.document.getLineNumber( lineHandle )

                    this.editor.setGutterMarker( currentLine, "CodeMirror-markers", null )

                    this.editor.removeLineClass( currentLine, "wrap", "CodeMirror-markedline-" + type )
                    this.editor.removeLineClass( currentLine, "gutter", "CodeMirror-markedline-gutter-" + type )
                } )
            } )
        },
        enablePickerButtons() {
            this.pickerButtons = []
            this.uniforms.forEach( ( uniformEditor, range ) => {
                const pickerButton = document.createElement( "span" )
                pickerButton.className = "picker-button"
                pickerButton.innerText = uniformEditor.target
                pickerButton.addEventListener( "click", ( event ) => {
                    const scroll = this.editor.getScrollerElement()
                    let offsetElement = pickerButton.offsetParent as HTMLElement
                    let offsetLeft = pickerButton.offsetLeft
                    let offsetTop = pickerButton.offsetTop
                    while ( offsetElement !== scroll ) {
                        offsetLeft += offsetElement.offsetLeft
                        offsetTop += offsetElement.offsetTop
                        offsetElement = offsetElement.offsetParent as HTMLElement
                    }
                    const bounds = pickerButton.getBoundingClientRect()
                    const x = offsetLeft + bounds.width / 2
                    const y = offsetTop + bounds.height / 2

                    this.uniformSelectedPosition = { x, y }
                    this.uniformSelectedEditor = uniformEditor
                    this.showPicker = true

                    document.addEventListener( "mousedown", this.handleClicksOutside )
                    this.editor.on( "scroll", this.handleScroll )
                } )
                const button = this.document.markText( range.from, range.to, { replacedWith: pickerButton } )
                this.pickerButtons.push( button )
            } )
        },
        disablePickerButtons( event: KeyboardEvent ) {
            if ( event.key === "Alt" ) {
                for ( let button of this.pickerButtons ) {
                    button.clear()
                }
            }
        },
        handleClicksOutside( event: MouseEvent ) {
            const clickableArea = ( this.$refs.pickerContainer as Vue ).$el as Element
            if ( clickableArea && ! clickableArea.contains( event.target as Node ) ) {
                this.showPicker = false
                document.removeEventListener( "mousedown", this.handleClicksOutside )
            }
        },
        handleScroll() {
            this.showPicker = false
            this.editor.off( "scroll", this.handleScroll )
        }
    },
    watch: {
        value( newValue: string ) {
            if ( newValue !== this.editor.getValue() ) {
                this.editor.setValue( newValue )
            }
        },
        log( newLog: LogEntry[] ) {
            const errors: Map < number, string[] > = new Map()
            const warnings: Map < number, string[] > = new Map()

            // separo el log en errores y warnings, agrupandolos por nro. de linea
            for ( let entry of newLog ) {
                const target = entry.type === LogEntryType.Error ? errors : warnings
                const line = entry.line - 1 // one-based -> zero-based
                const lineEntries = target.get( line )

                if ( lineEntries === undefined ) {
                    target.set( line, [ entry.description ] )
                } else {
                    lineEntries.push( entry.description )
                }
            }

            this.showLog( errors, LogEntryType.Error )

            if ( errors.size === 0 ) {
                this.showLog( warnings, LogEntryType.Warning )
            }
        },
        uniformsEditors( newUniformsEditors: UniformEditor[] ) {
            // ⚠️ contemplar que se deberian poder editar solo cuando no hay errores

            const uniformsEditors: Map <string, UniformEditor> = new Map()
            const uniformsNames: Array <string> = []

            for ( let editor of newUniformsEditors ) {
                // mapa para acceso rapido de editores
                uniformsEditors.set( editor.target, editor )
                // nombres de uniforms desarmados:
                //  • "viewMatrix"     -> [ "viewMatrix" ]
                //  • "light.position" -> [ "light", "position" ]
                uniformsNames.push( editor.target )
            }

            // los separo en "basicos" y "estructuras" (con sus componentes)
            const basic: string[] = [] // [ "viewMatrix", ... ]
            const structs: Map < string, string[] > = new Map() // "light" -> [ "position", "color", ... ]

            for ( let name of uniformsNames ) {
                const nameParts = name.split( "." )
                if ( nameParts.length === 1 ) {
                    // [ "viewMatrix" ]
                    const identifier = nameParts[ 0 ]
                    basic.push( identifier )
                } else {
                    // [ "light", "position" ]
                    const structIdentifier = nameParts[ 0 ]
                    const structAttribute = nameParts[ 1 ]
                    const structAttributes = structs.get( structIdentifier )
                    if ( structAttributes !== undefined ) {
                        structAttributes.push( structAttribute )
                    } else {
                        structs.set( structIdentifier, [ structAttribute ] )
                    }
                }
            }

            // encuentro los rangos en el codigo que ocupan los uniforms
            this.uniforms.clear()
            const lineCount = this.document.lineCount()

            for ( let lineNumber = 0; lineNumber < lineCount; lineNumber ++ ) {
                const lineTokens = this.editor.getLineTokens( lineNumber )
                for ( let tokenNumber = 0; tokenNumber < lineTokens.length; tokenNumber ++ ) {
                    const token = lineTokens[ tokenNumber ]
                    if ( token.type === "identifier" ) {
                        if ( basic.includes( token.string ) ) {
                            const from: CodeMirror.Position = { line: lineNumber, ch: token.start }
                            const to: CodeMirror.Position   = { line: lineNumber, ch: token.end }
                            this.uniforms.set( { from, to }, uniformsEditors.get( token.string ) as UniformEditor )
                        } else {
                            const structComponents = structs.get( token.string )
                            if ( structComponents !== undefined ) {
                                const possibleAttribute = lineTokens[ tokenNumber + 2 ] // [ ... "light", ".", >"position"< ... ]
                                if ( possibleAttribute && possibleAttribute.type === "attribute" && structComponents.includes( possibleAttribute.string ) ) {
                                    const from: CodeMirror.Position = { line: lineNumber, ch: token.start }
                                    const to: CodeMirror.Position   = { line: lineNumber, ch: possibleAttribute.end }
                                    this.uniforms.set( { from, to }, uniformsEditors.get( token.string + "." + possibleAttribute.string ) as UniformEditor )
                                }
                            }
                        }
                    }
                }
            }

            // resalto rangos encontrados
            this.uniforms.forEach( ( editor, range ) => {
                this.document.markText( range.from, range.to, { className: "editable" } )
            } )
        }
    }
} )
</script>

<style src="./codemirror/theme/dark.css"></style>
